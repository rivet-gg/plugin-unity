// This file is auto-generated by the Open Game Backend (https://opengb.dev) build system.
// 
// Do not edit this file directly.
//
// Generated at 2024-07-28T09:51:45.804Z

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Backend.Client;
using Backend.Model;

namespace Backend.Modules
{
	/// <summary>
	/// Represents a collection of functions to interact with the API endpoints
	/// </summary>
	public partial class LobbiesApi : IDisposable
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="LobbiesApi"/> class.
		/// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
		/// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
		/// </summary>
		/// <returns></returns>
		public LobbiesApi() : this((string)null)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LobbiesApi"/> class.
		/// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
		/// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
		/// </summary>
		/// <param name="basePath">The target service's base path in URL format.</param>
		/// <exception cref="ArgumentException"></exception>
		/// <returns></returns>
		public LobbiesApi(string basePath)
		{
			this.Configuration = Backend.Client.Configuration.MergeConfigurations(
				Backend.Client.GlobalConfiguration.Instance,
				new Backend.Client.Configuration { BasePath = basePath }
			);
			this.ApiClient = new Backend.Client.ApiClient(this.Configuration.BasePath);
			this.AsynchronousClient = this.ApiClient;
			this.ExceptionFactory = Backend.Client.Configuration.DefaultExceptionFactory;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LobbiesApi"/> class using Configuration object.
		/// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
		/// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
		/// </summary>
		/// <param name="configuration">An instance of Configuration.</param>
		/// <exception cref="ArgumentNullException"></exception>
		/// <returns></returns>
		public LobbiesApi(Backend.Client.Configuration configuration)
		{
			if (configuration == null) throw new ArgumentNullException("configuration");

			this.Configuration = Backend.Client.Configuration.MergeConfigurations(
				Backend.Client.GlobalConfiguration.Instance,
				configuration
			);
			this.ApiClient = new Backend.Client.ApiClient(this.Configuration.BasePath);
			this.AsynchronousClient = this.ApiClient;
			ExceptionFactory = Backend.Client.Configuration.DefaultExceptionFactory;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LobbiesApi"/> class
		/// using a Configuration object and client instance.
		/// </summary>
		/// <param name="asyncClient">The client interface for asynchronous API access.</param>
		/// <param name="configuration">The configuration object.</param>
		/// <exception cref="ArgumentNullException"></exception>
		public LobbiesApi(Backend.Client.IAsynchronousClient asyncClient, Backend.Client.IReadableConfiguration configuration)
		{
			if (asyncClient == null) throw new ArgumentNullException("asyncClient");
			if (configuration == null) throw new ArgumentNullException("configuration");

			this.AsynchronousClient = asyncClient;
			this.Configuration = configuration;
			this.ExceptionFactory = Backend.Client.Configuration.DefaultExceptionFactory;
		}

		/// <summary>
		/// Disposes resources if they were created by us
		/// </summary>
		public void Dispose()
		{
			this.ApiClient?.Dispose();
		}

		/// <summary>
		/// Holds the ApiClient if created
		/// </summary>
		public Backend.Client.ApiClient ApiClient { get; set; } = null;

		/// <summary>
		/// The client for accessing this underlying API asynchronously.
		/// </summary>
		public Backend.Client.IAsynchronousClient AsynchronousClient { get; set; }

		/// <summary>
		/// Gets the base path of the API client.
		/// </summary>
		/// <value>The base path</value>
		public string GetBasePath()
		{
			return this.Configuration.BasePath;
		}

		/// <summary>
		/// Gets or sets the configuration object
		/// </summary>
		/// <value>An instance of the Configuration</value>
		public Backend.Client.IReadableConfiguration Configuration { get; set; }

		private Backend.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

		/// <summary>
		/// Provides a factory method hook for the creation of exceptions.
		/// </summary>
		public Backend.Client.ExceptionFactory ExceptionFactory
		{
			get
			{
				if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
				{
					throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
				}
				return _exceptionFactory;
			}
			set { _exceptionFactory = value; }
		}

/// <summary>
		///  Call lobbies.create script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.CreateResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.CreateResponse> Create(Backend.Model.Lobbies.CreateRequest lobbiesCreateRequest = default(Backend.Model.Lobbies.CreateRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = CreateWithHttpInfo(lobbiesCreateRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.CreateResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.CreateResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.create script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.CreateResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.CreateResponse>> CreateWithHttpInfo(Backend.Model.Lobbies.CreateRequest lobbiesCreateRequest = default(Backend.Model.Lobbies.CreateRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesCreateRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.CreateResponse>("/modules/lobbies/scripts/create/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("Create", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.destroy script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.DestroyResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.DestroyResponse> Destroy(Backend.Model.Lobbies.DestroyRequest lobbiesDestroyRequest = default(Backend.Model.Lobbies.DestroyRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = DestroyWithHttpInfo(lobbiesDestroyRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.DestroyResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.DestroyResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.destroy script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.DestroyResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.DestroyResponse>> DestroyWithHttpInfo(Backend.Model.Lobbies.DestroyRequest lobbiesDestroyRequest = default(Backend.Model.Lobbies.DestroyRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesDestroyRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.DestroyResponse>("/modules/lobbies/scripts/destroy/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("Destroy", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.find_or_create script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.FindOrCreateResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.FindOrCreateResponse> FindOrCreate(Backend.Model.Lobbies.FindOrCreateRequest lobbiesFindOrCreateRequest = default(Backend.Model.Lobbies.FindOrCreateRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = FindOrCreateWithHttpInfo(lobbiesFindOrCreateRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.FindOrCreateResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.FindOrCreateResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.find_or_create script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.FindOrCreateResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.FindOrCreateResponse>> FindOrCreateWithHttpInfo(Backend.Model.Lobbies.FindOrCreateRequest lobbiesFindOrCreateRequest = default(Backend.Model.Lobbies.FindOrCreateRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesFindOrCreateRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.FindOrCreateResponse>("/modules/lobbies/scripts/find_or_create/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("FindOrCreate", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.join script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.JoinResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.JoinResponse> Join(Backend.Model.Lobbies.JoinRequest lobbiesJoinRequest = default(Backend.Model.Lobbies.JoinRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = JoinWithHttpInfo(lobbiesJoinRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.JoinResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.JoinResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.join script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.JoinResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.JoinResponse>> JoinWithHttpInfo(Backend.Model.Lobbies.JoinRequest lobbiesJoinRequest = default(Backend.Model.Lobbies.JoinRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesJoinRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.JoinResponse>("/modules/lobbies/scripts/join/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("Join", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.list script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.ListResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.ListResponse> List(Backend.Model.Lobbies.ListRequest lobbiesListRequest = default(Backend.Model.Lobbies.ListRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = ListWithHttpInfo(lobbiesListRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.ListResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.ListResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.list script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.ListResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.ListResponse>> ListWithHttpInfo(Backend.Model.Lobbies.ListRequest lobbiesListRequest = default(Backend.Model.Lobbies.ListRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesListRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.ListResponse>("/modules/lobbies/scripts/list/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("List", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.set_lobby_ready script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.SetLobbyReadyResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.SetLobbyReadyResponse> SetLobbyReady(Backend.Model.Lobbies.SetLobbyReadyRequest lobbiesSetLobbyReadyRequest = default(Backend.Model.Lobbies.SetLobbyReadyRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = SetLobbyReadyWithHttpInfo(lobbiesSetLobbyReadyRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.SetLobbyReadyResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.SetLobbyReadyResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.set_lobby_ready script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.SetLobbyReadyResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.SetLobbyReadyResponse>> SetLobbyReadyWithHttpInfo(Backend.Model.Lobbies.SetLobbyReadyRequest lobbiesSetLobbyReadyRequest = default(Backend.Model.Lobbies.SetLobbyReadyRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesSetLobbyReadyRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.SetLobbyReadyResponse>("/modules/lobbies/scripts/set_lobby_ready/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("SetLobbyReady", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.set_player_connected script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.SetPlayerConnectedResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.SetPlayerConnectedResponse> SetPlayerConnected(Backend.Model.Lobbies.SetPlayerConnectedRequest lobbiesSetPlayerConnectedRequest = default(Backend.Model.Lobbies.SetPlayerConnectedRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = SetPlayerConnectedWithHttpInfo(lobbiesSetPlayerConnectedRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.SetPlayerConnectedResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.SetPlayerConnectedResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.set_player_connected script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.SetPlayerConnectedResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.SetPlayerConnectedResponse>> SetPlayerConnectedWithHttpInfo(Backend.Model.Lobbies.SetPlayerConnectedRequest lobbiesSetPlayerConnectedRequest = default(Backend.Model.Lobbies.SetPlayerConnectedRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesSetPlayerConnectedRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.SetPlayerConnectedResponse>("/modules/lobbies/scripts/set_player_connected/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("SetPlayerConnected", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.set_player_disconnected script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.SetPlayerDisconnectedResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.SetPlayerDisconnectedResponse> SetPlayerDisconnected(Backend.Model.Lobbies.SetPlayerDisconnectedRequest lobbiesSetPlayerDisconnectedRequest = default(Backend.Model.Lobbies.SetPlayerDisconnectedRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = SetPlayerDisconnectedWithHttpInfo(lobbiesSetPlayerDisconnectedRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.SetPlayerDisconnectedResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.SetPlayerDisconnectedResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.set_player_disconnected script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.SetPlayerDisconnectedResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.SetPlayerDisconnectedResponse>> SetPlayerDisconnectedWithHttpInfo(Backend.Model.Lobbies.SetPlayerDisconnectedRequest lobbiesSetPlayerDisconnectedRequest = default(Backend.Model.Lobbies.SetPlayerDisconnectedRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesSetPlayerDisconnectedRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.SetPlayerDisconnectedResponse>("/modules/lobbies/scripts/set_player_disconnected/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("SetPlayerDisconnected", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.find script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.FindResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.FindResponse> Find(Backend.Model.Lobbies.FindRequest lobbiesFindRequest = default(Backend.Model.Lobbies.FindRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = FindWithHttpInfo(lobbiesFindRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.FindResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.FindResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.find script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.FindResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.FindResponse>> FindWithHttpInfo(Backend.Model.Lobbies.FindRequest lobbiesFindRequest = default(Backend.Model.Lobbies.FindRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesFindRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.FindResponse>("/modules/lobbies/scripts/find/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("Find", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.force_gc script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.ForceGcResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.ForceGcResponse> ForceGc(Backend.Model.Lobbies.ForceGcRequest lobbiesForceGcRequest = default(Backend.Model.Lobbies.ForceGcRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = ForceGcWithHttpInfo(lobbiesForceGcRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.ForceGcResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.ForceGcResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.force_gc script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.ForceGcResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.ForceGcResponse>> ForceGcWithHttpInfo(Backend.Model.Lobbies.ForceGcRequest lobbiesForceGcRequest = default(Backend.Model.Lobbies.ForceGcRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesForceGcRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.ForceGcResponse>("/modules/lobbies/scripts/force_gc/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("ForceGc", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}

/// <summary>
		///  Call lobbies.list_regions script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of Backend.Model.Lobbies.ListRegionsResponse</returns>
		public async System.Threading.Tasks.Task<Backend.Model.Lobbies.ListRegionsResponse> ListRegions(Backend.Model.Lobbies.ListRegionsRequest lobbiesListRegionsRequest = default(Backend.Model.Lobbies.ListRegionsRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{
			var task = ListRegionsWithHttpInfo(lobbiesListRegionsRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
			Backend.Client.ApiResponse<Backend.Model.Lobbies.ListRegionsResponse> localVarResponse = await task.ConfigureAwait(false);
#else
			Backend.Client.ApiResponse<Backend.Model.Lobbies.ListRegionsResponse> localVarResponse = await task;
#endif
			return localVarResponse.Data;
		}

		/// <summary>
		///  Call lobbies.list_regions script.
		/// </summary>
		/// <exception cref="Backend.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="body"> (optional)</param>
		/// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
		/// <returns>Task of ApiResponse (Backend.Model.Lobbies.ListRegionsResponse)</returns>
		public async System.Threading.Tasks.Task<Backend.Client.ApiResponse<Backend.Model.Lobbies.ListRegionsResponse>> ListRegionsWithHttpInfo(Backend.Model.Lobbies.ListRegionsRequest lobbiesListRegionsRequest = default(Backend.Model.Lobbies.ListRegionsRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
		{

			Backend.Client.RequestOptions localVarRequestOptions = new Backend.Client.RequestOptions();

			string[] _contentTypes = new string[] {
				"application/json"
			};

			// to determine the Accept header
			string[] _accepts = new string[] {
				"application/json"
			};


			var localVarContentType = Backend.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
			if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

			var localVarAccept = Backend.Client.ClientUtils.SelectHeaderAccept(_accepts);
			if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

			localVarRequestOptions.Data = lobbiesListRegionsRequest;


			// make the HTTP request

			var task = this.AsynchronousClient.PostAsync<Backend.Model.Lobbies.ListRegionsResponse>("/modules/lobbies/scripts/list_regions/call", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
			var localVarResponse = await task.ConfigureAwait(false);
#else
			var localVarResponse = await task;
#endif

			if (this.ExceptionFactory != null)
			{
				Exception _exception = this.ExceptionFactory("ListRegions", localVarResponse);
				if (_exception != null) throw _exception;
			}

			return localVarResponse;
		}


				}
			}
			



