// This file is auto-generated by the Open Game Backend (https://opengb.dev) build system.
//
// Do not edit this file directly.
//
// Generated at 2024-07-30T15:15:37.842Z
import {
	BuildRuntime,
	Config,
} from "/Users/nathan/rivet/plugin-unity/.opengb/runtime/packages/runtime/src/mod.ts";

// Schemas
import * as z from "npm:zod@3.23.8";

// Import Prisma adapter for Postgres
//
// We can't use esm.sh for these because they rely on special Node
// functionality & don't need to be portable
//
// https://github.com/esm-dev/esm.sh/issues/684
import pg from "npm:pg@^8.11.3";
import { PrismaPg } from "npm:@prisma/adapter-pg@^5.12.0";

import { run as modules$$users$$fetch$$run } from "/Users/nathan/rivet/opengb-modules/modules/users/scripts/fetch.ts";
import { run as modules$$users$$create$$run } from "/Users/nathan/rivet/opengb-modules/modules/users/scripts/create.ts";
import { run as modules$$users$$authenticate_token$$run } from "/Users/nathan/rivet/opengb-modules/modules/users/scripts/authenticate_token.ts";
import { run as modules$$users$$create_token$$run } from "/Users/nathan/rivet/opengb-modules/modules/users/scripts/create_token.ts";
import prisma$$users from "/Users/nathan/rivet/plugin-unity/.opengb/prisma_output/users/esm.js";
import { run as modules$$rate_limit$$throttle$$run } from "/Users/nathan/rivet/opengb-modules/modules/rate_limit/scripts/throttle.ts";
import { run as modules$$rate_limit$$throttle_public$$run } from "/Users/nathan/rivet/opengb-modules/modules/rate_limit/scripts/throttle_public.ts";
import { Actor as modules$$rate_limit$$limiter$$Actor } from "/Users/nathan/rivet/opengb-modules/modules/rate_limit/actors/limiter.ts";
import prisma$$rate_limit from "/Users/nathan/rivet/plugin-unity/.opengb/prisma_output/rate_limit/esm.js";
import { run as modules$$tokens$$create$$run } from "/Users/nathan/rivet/opengb-modules/modules/tokens/scripts/create.ts";
import { run as modules$$tokens$$fetch$$run } from "/Users/nathan/rivet/opengb-modules/modules/tokens/scripts/fetch.ts";
import { run as modules$$tokens$$fetch_by_token$$run } from "/Users/nathan/rivet/opengb-modules/modules/tokens/scripts/fetch_by_token.ts";
import { run as modules$$tokens$$revoke$$run } from "/Users/nathan/rivet/opengb-modules/modules/tokens/scripts/revoke.ts";
import { run as modules$$tokens$$validate$$run } from "/Users/nathan/rivet/opengb-modules/modules/tokens/scripts/validate.ts";
import { run as modules$$tokens$$extend$$run } from "/Users/nathan/rivet/opengb-modules/modules/tokens/scripts/extend.ts";
import prisma$$tokens from "/Users/nathan/rivet/plugin-unity/.opengb/prisma_output/tokens/esm.js";
import { run as modules$$lobbies$$create$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/create.ts";
import { run as modules$$lobbies$$destroy$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/destroy.ts";
import { run as modules$$lobbies$$find_or_create$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/find_or_create.ts";
import { run as modules$$lobbies$$join$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/join.ts";
import { run as modules$$lobbies$$list$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/list.ts";
import { run as modules$$lobbies$$set_lobby_ready$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/set_lobby_ready.ts";
import { run as modules$$lobbies$$set_player_connected$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/set_player_connected.ts";
import { run as modules$$lobbies$$set_player_disconnected$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/set_player_disconnected.ts";
import { run as modules$$lobbies$$find$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/find.ts";
import { run as modules$$lobbies$$force_gc$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/force_gc.ts";
import { run as modules$$lobbies$$list_regions$$run } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/scripts/list_regions.ts";
import { Actor as modules$$lobbies$$lobby_manager$$Actor } from "/Users/nathan/rivet/opengb-modules/modules/lobbies/actors/lobby_manager.ts";
import { run as modules$$rivet$$call$$run } from "/Users/nathan/rivet/opengb-modules/modules/rivet/scripts/call.ts";

export default {
	runtime: BuildRuntime.Deno,
	modules: {
		"users": {
			"storageAlias": "users",
			scripts: {
				"fetch": {
					run: modules$$users$$fetch$$run,
					public: true,
					requestSchema: z.object({ userIds: z.array(z.string()) }),
					responseSchema: z.object({
						users: z.array(
							z.object({
								id: z.string(),
								username: z.string(),
								createdAt: z.date(),
								updatedAt: z.date(),
							}),
						),
					}),
				},
				"create": {
					run: modules$$users$$create$$run,
					public: false,
					requestSchema: z.object({
						username: z.optional(
							z.string(),
						),
					}),
					responseSchema: z.object({
						user: z.object({
							id: z.string(),
							username: z.string(),
							createdAt: z.date(),
							updatedAt: z.date(),
						}),
					}),
				},
				"authenticate_token": {
					run: modules$$users$$authenticate_token$$run,
					public: true,
					requestSchema: z.object({
						userToken: z.string(),
						fetchUser: z.optional(
							z.boolean(),
						),
					}),
					responseSchema: z.object({
						userId: z.string(),
						user: z.optional(
							z.object({
								id: z.string(),
								username: z.string(),
								createdAt: z.date(),
								updatedAt: z.date(),
							}),
						),
					}),
				},
				"create_token": {
					run: modules$$users$$create_token$$run,
					public: false,
					requestSchema: z.object({ userId: z.string() }),
					responseSchema: z.object({
						token: z.object({
							token: z.string(),
							id: z.string(),
							type: z.string(),
							meta: z.any(),
							createdAt: z.string(),
							expireAt: z.nullable(z.string()),
							revokedAt: z.nullable(z.string()),
						}),
					}),
				},
			},
			actors: {},
			routes: {},
			errors: {
				"token_not_user_token": { "name": "Token Not User Token" },
				"unknown_identity_type": { "name": "Unknown Identity Type" },
			},
			dependencies: new Set(["users", "rate_limit", "tokens"]),
			db: {
				schema: "module_users",
				createPrismaClient: (pgPool: pg.Pool, schema: string) => {
					const adapter = new PrismaPg(pgPool, { schema });
					const prisma = new prisma$$users.PrismaClient({
						adapter,
						log: ["query", "info", "warn", "error"],
					});
					return prisma;
				},
			},
			userConfig: {},
		},
		"rate_limit": {
			"storageAlias": "rate_limit",
			scripts: {
				"throttle": {
					run: modules$$rate_limit$$throttle$$run,
					public: false,
					requestSchema: z.object({
						type: z.string(),
						key: z.string(),
						requests: z.number(),
						period: z.number(),
					}),
					responseSchema: z.record(z.never()),
				},
				"throttle_public": {
					run: modules$$rate_limit$$throttle_public$$run,
					public: false,
					requestSchema: z.object({
						requests: z.optional(
							z.number(),
						),
						period: z.optional(
							z.number(),
						),
					}),
					responseSchema: z.record(z.never()),
				},
			},
			actors: {
				"limiter": {
					actor: modules$$rate_limit$$limiter$$Actor,
					storageAlias: "limiter",
				},
			},
			routes: {},
			errors: { "rate_limit_exceeded": { "name": "Rate Limit Exceeded" } },
			dependencies: new Set(["rate_limit"]),
			db: {
				schema: "module_rate_limit",
				createPrismaClient: (pgPool: pg.Pool, schema: string) => {
					const adapter = new PrismaPg(pgPool, { schema });
					const prisma = new prisma$$rate_limit.PrismaClient({
						adapter,
						log: ["query", "info", "warn", "error"],
					});
					return prisma;
				},
			},
			userConfig: {},
		},
		"tokens": {
			"storageAlias": "tokens",
			scripts: {
				"create": {
					run: modules$$tokens$$create$$run,
					public: false,
					requestSchema: z.object({
						type: z.string(),
						meta: z.record(z.string()),
						expireAt: z.optional(
							z.string(),
						),
					}),
					responseSchema: z.object({
						token: z.object({
							token: z.string(),
							id: z.string(),
							type: z.string(),
							meta: z.any(),
							createdAt: z.string(),
							expireAt: z.nullable(z.string()),
							revokedAt: z.nullable(z.string()),
						}),
					}),
				},
				"fetch": {
					run: modules$$tokens$$fetch$$run,
					public: false,
					requestSchema: z.object({ tokenIds: z.array(z.string()) }),
					responseSchema: z.object({
						tokens: z.array(
							z.object({
								id: z.string(),
								type: z.string(),
								meta: z.any(),
								createdAt: z.string(),
								expireAt: z.nullable(z.string()),
								revokedAt: z.nullable(z.string()),
							}),
						),
					}),
				},
				"fetch_by_token": {
					run: modules$$tokens$$fetch_by_token$$run,
					public: false,
					requestSchema: z.object({ tokens: z.array(z.string()) }),
					responseSchema: z.object({
						tokens: z.array(
							z.object({
								id: z.string(),
								type: z.string(),
								meta: z.any(),
								createdAt: z.string(),
								expireAt: z.nullable(z.string()),
								revokedAt: z.nullable(z.string()),
							}),
						),
					}),
				},
				"revoke": {
					run: modules$$tokens$$revoke$$run,
					public: false,
					requestSchema: z.object({ tokenIds: z.array(z.string()) }),
					responseSchema: z.object({ updates: z.object({}) }),
				},
				"validate": {
					run: modules$$tokens$$validate$$run,
					public: false,
					requestSchema: z.object({ token: z.string() }),
					responseSchema: z.object({
						token: z.object({
							id: z.string(),
							type: z.string(),
							meta: z.any(),
							createdAt: z.string(),
							expireAt: z.nullable(z.string()),
							revokedAt: z.nullable(z.string()),
						}),
					}),
				},
				"extend": {
					run: modules$$tokens$$extend$$run,
					public: false,
					requestSchema: z.object({
						token: z.string(),
						newExpiration: z.nullable(z.string()),
					}),
					responseSchema: z.object({
						token: z.object({
							token: z.string(),
							id: z.string(),
							type: z.string(),
							meta: z.any(),
							createdAt: z.string(),
							expireAt: z.nullable(z.string()),
							revokedAt: z.nullable(z.string()),
						}),
					}),
				},
			},
			actors: {},
			routes: {},
			errors: {
				"token_not_found": { "name": "Token Not Found" },
				"token_revoked": { "name": "Token Revoked" },
				"token_expired": { "name": "Token Expired" },
			},
			dependencies: new Set(["tokens"]),
			db: {
				schema: "module_tokens",
				createPrismaClient: (pgPool: pg.Pool, schema: string) => {
					const adapter = new PrismaPg(pgPool, { schema });
					const prisma = new prisma$$tokens.PrismaClient({
						adapter,
						log: ["query", "info", "warn", "error"],
					});
					return prisma;
				},
			},
			userConfig: {},
		},
		"lobbies": {
			"storageAlias": "lobbies",
			scripts: {
				"create": {
					run: modules$$lobbies$$create$$run,
					public: true,
					requestSchema: z.object({
						version: z.string(),
						region: z.string(),
						tags: z.optional(
							z.record(z.string()),
						),
						maxPlayers: z.number(),
						maxPlayersDirect: z.number(),
						players: z.array(z.object({})),
						noWait: z.optional(
							z.boolean(),
						),
					}),
					responseSchema: z.object({
						lobby: z.object({
							id: z.string(),
							version: z.string(),
							tags: z.record(z.string()),
							createdAt: z.number(),
							readyAt: z.optional(
								z.number(),
							),
							players: z.number(),
							maxPlayers: z.number(),
							maxPlayersDirect: z.number(),
							backend: z.union([
								z.object({ test: z.object({}) }),
								z.object({
									localDevelopment: z.object({
										ports: z.record(
											z.object({
												protocol: z.union([
													z.literal("http"),
													z.literal("tcp"),
													z.literal("udp"),
												]),
												hostname: z.string(),
												port: z.number(),
											}),
										),
									}),
								}),
								z.object({
									server: z.object({
										serverId: z.string(),
										ports: z.optional(
											z.record(
												z.object({
													protocol: z.union([
														z.literal("http"),
														z.literal("tcp"),
														z.literal("udp"),
														z.literal("https"),
														z.literal("tcp_tls"),
													]),
													serverPort: z.optional(
														z.number(),
													),
													publicHostname: z.optional(
														z.string(),
													),
													publicPort: z.optional(
														z.number(),
													),
													routing: z.object({
														game_guard: z.optional(
															z.object({}),
														),
														host: z.optional(
															z.object({}),
														),
													}),
												}),
											),
										),
									}),
								}),
							]),
						}),
						players: z.array(z.object({ token: z.string(), id: z.string() })),
					}),
				},
				"destroy": {
					run: modules$$lobbies$$destroy$$run,
					public: true,
					requestSchema: z.object({ lobbyId: z.string() }),
					responseSchema: z.object({}),
				},
				"find_or_create": {
					run: modules$$lobbies$$find_or_create$$run,
					public: true,
					requestSchema: z.object({
						version: z.string(),
						regions: z.optional(
							z.array(z.string()),
						),
						tags: z.optional(
							z.record(z.string()),
						),
						players: z.array(z.object({})),
						noWait: z.optional(
							z.boolean(),
						),
						createConfig: z.object({
							region: z.string(),
							tags: z.optional(
								z.record(z.string()),
							),
							maxPlayers: z.number(),
							maxPlayersDirect: z.number(),
						}),
					}),
					responseSchema: z.object({
						lobby: z.object({
							id: z.string(),
							version: z.string(),
							tags: z.record(z.string()),
							createdAt: z.number(),
							readyAt: z.optional(
								z.number(),
							),
							players: z.number(),
							maxPlayers: z.number(),
							maxPlayersDirect: z.number(),
							backend: z.union([
								z.object({ test: z.object({}) }),
								z.object({
									localDevelopment: z.object({
										ports: z.record(
											z.object({
												protocol: z.union([
													z.literal("http"),
													z.literal("tcp"),
													z.literal("udp"),
												]),
												hostname: z.string(),
												port: z.number(),
											}),
										),
									}),
								}),
								z.object({
									server: z.object({
										serverId: z.string(),
										ports: z.optional(
											z.record(
												z.object({
													protocol: z.union([
														z.literal("http"),
														z.literal("tcp"),
														z.literal("udp"),
														z.literal("https"),
														z.literal("tcp_tls"),
													]),
													serverPort: z.optional(
														z.number(),
													),
													publicHostname: z.optional(
														z.string(),
													),
													publicPort: z.optional(
														z.number(),
													),
													routing: z.object({
														game_guard: z.optional(
															z.object({}),
														),
														host: z.optional(
															z.object({}),
														),
													}),
												}),
											),
										),
									}),
								}),
							]),
						}),
						players: z.array(z.object({ token: z.string(), id: z.string() })),
					}),
				},
				"join": {
					run: modules$$lobbies$$join$$run,
					public: true,
					requestSchema: z.object({
						lobbyId: z.string(),
						players: z.array(z.object({})),
						noWait: z.optional(
							z.boolean(),
						),
					}),
					responseSchema: z.object({
						lobby: z.object({
							id: z.string(),
							version: z.string(),
							tags: z.record(z.string()),
							createdAt: z.number(),
							readyAt: z.optional(
								z.number(),
							),
							players: z.number(),
							maxPlayers: z.number(),
							maxPlayersDirect: z.number(),
							backend: z.union([
								z.object({ test: z.object({}) }),
								z.object({
									localDevelopment: z.object({
										ports: z.record(
											z.object({
												protocol: z.union([
													z.literal("http"),
													z.literal("tcp"),
													z.literal("udp"),
												]),
												hostname: z.string(),
												port: z.number(),
											}),
										),
									}),
								}),
								z.object({
									server: z.object({
										serverId: z.string(),
										ports: z.optional(
											z.record(
												z.object({
													protocol: z.union([
														z.literal("http"),
														z.literal("tcp"),
														z.literal("udp"),
														z.literal("https"),
														z.literal("tcp_tls"),
													]),
													serverPort: z.optional(
														z.number(),
													),
													publicHostname: z.optional(
														z.string(),
													),
													publicPort: z.optional(
														z.number(),
													),
													routing: z.object({
														game_guard: z.optional(
															z.object({}),
														),
														host: z.optional(
															z.object({}),
														),
													}),
												}),
											),
										),
									}),
								}),
							]),
						}),
						players: z.array(z.object({ token: z.string(), id: z.string() })),
					}),
				},
				"list": {
					run: modules$$lobbies$$list$$run,
					public: true,
					requestSchema: z.object({
						version: z.string(),
						regions: z.optional(
							z.array(z.string()),
						),
						tags: z.optional(
							z.record(z.string()),
						),
					}),
					responseSchema: z.object({
						lobbies: z.array(
							z.object({
								id: z.string(),
								version: z.string(),
								tags: z.record(z.string()),
							}),
						),
					}),
				},
				"set_lobby_ready": {
					run: modules$$lobbies$$set_lobby_ready$$run,
					public: true,
					requestSchema: z.object({
						lobbyId: z.optional(
							z.string(),
						),
						lobbyToken: z.optional(
							z.string(),
						),
					}),
					responseSchema: z.object({}),
				},
				"set_player_connected": {
					run: modules$$lobbies$$set_player_connected$$run,
					public: true,
					requestSchema: z.object({
						lobbyId: z.optional(
							z.string(),
						),
						lobbyToken: z.optional(
							z.string(),
						),
						playerTokens: z.array(z.string()),
					}),
					responseSchema: z.object({}),
				},
				"set_player_disconnected": {
					run: modules$$lobbies$$set_player_disconnected$$run,
					public: true,
					requestSchema: z.object({
						lobbyId: z.optional(
							z.string(),
						),
						lobbyToken: z.optional(
							z.string(),
						),
						playerTokens: z.array(z.string()),
					}),
					responseSchema: z.object({}),
				},
				"find": {
					run: modules$$lobbies$$find$$run,
					public: true,
					requestSchema: z.object({
						version: z.string(),
						regions: z.optional(
							z.array(z.string()),
						),
						tags: z.optional(
							z.record(z.string()),
						),
						players: z.array(z.object({})),
						noWait: z.optional(
							z.boolean(),
						),
					}),
					responseSchema: z.object({
						lobby: z.object({
							id: z.string(),
							version: z.string(),
							tags: z.record(z.string()),
							createdAt: z.number(),
							readyAt: z.optional(
								z.number(),
							),
							players: z.number(),
							maxPlayers: z.number(),
							maxPlayersDirect: z.number(),
							backend: z.union([
								z.object({ test: z.object({}) }),
								z.object({
									localDevelopment: z.object({
										ports: z.record(
											z.object({
												protocol: z.union([
													z.literal("http"),
													z.literal("tcp"),
													z.literal("udp"),
												]),
												hostname: z.string(),
												port: z.number(),
											}),
										),
									}),
								}),
								z.object({
									server: z.object({
										serverId: z.string(),
										ports: z.optional(
											z.record(
												z.object({
													protocol: z.union([
														z.literal("http"),
														z.literal("tcp"),
														z.literal("udp"),
														z.literal("https"),
														z.literal("tcp_tls"),
													]),
													serverPort: z.optional(
														z.number(),
													),
													publicHostname: z.optional(
														z.string(),
													),
													publicPort: z.optional(
														z.number(),
													),
													routing: z.object({
														game_guard: z.optional(
															z.object({}),
														),
														host: z.optional(
															z.object({}),
														),
													}),
												}),
											),
										),
									}),
								}),
							]),
						}),
						players: z.array(z.object({ token: z.string(), id: z.string() })),
					}),
				},
				"force_gc": {
					run: modules$$lobbies$$force_gc$$run,
					public: false,
					requestSchema: z.object({}),
					responseSchema: z.object({}),
				},
				"list_regions": {
					run: modules$$lobbies$$list_regions$$run,
					public: false,
					requestSchema: z.object({
						tags: z.optional(
							z.record(z.string()),
						),
					}),
					responseSchema: z.object({
						regions: z.array(
							z.object({
								id: z.string(),
								display_name: z.string(),
								latitude: z.number(),
								longitude: z.number(),
							}),
						),
					}),
				},
			},
			actors: {
				"lobby_manager": {
					actor: modules$$lobbies$$lobby_manager$$Actor,
					storageAlias: "lobby_manager",
				},
			},
			routes: {},
			errors: {
				"lobby_not_found": {
					"name": "Lobby Not Found",
					"description": "Lobby not found.",
				},
				"lobby_cancelled": {
					"name": "Lobby Cancelled",
					"description": "Lobby stopped while attempting to join.",
				},
				"lobby_create_missing_players": {
					"name": "Lobby Create Missing Players",
					"description":
						"When creating a lobby with `config.lobbies.autoDestroyWhenEmpty`, a lobby must be created with players in order to avoid creating an empty lobby.",
				},
				"lobby_full": {
					"name": "Lobby Full",
					"description": "No more players can join this lobby.",
				},
				"more_players_than_max": {
					"name": "More Players Than Max",
					"description":
						"More players were passed to the create lobby than the number of max players in a lobby.",
				},
				"lobby_already_ready": {
					"name": "Lobby Already Ready",
					"description": "Lobby already set as ready.",
				},
				"player_already_connected": {
					"name": "Player Already Connected",
					"description":
						"The player has already connected to this server. This error helps mitigate botting attacks by only allowing one scoket to connect to a game server for every player.",
				},
				"player_disconnected": {
					"name": "Player Disconnected",
					"description":
						"The player has already disconnected from the server. Create a new player for the specified lobby using the `join` script.",
				},
				"no_matching_lobbies": {
					"name": "No Matching Lobbies",
					"description": "No lobbies matched the given query.",
				},
				"too_many_players_for_ip": {
					"name": "Too Many Players For IP",
					"description":
						"The player has too many existing players for the given IP.",
				},
				"cannot_mutate_lobbies": {
					"name": "Cannot Mutate Lobbies",
					"description":
						"This backend doesn't let you create or destroy lobbies.",
				},
				"lobby_token_required": {
					"name": "Lobby Token Required",
					"description":
						"A lobby token was not provided when required for authentication.",
				},
				"region_not_found": {
					"name": "Region Not Found",
					"description": "Region not found.",
				},
			},
			dependencies: new Set(["lobbies", "tokens", "rivet"]),
			db: undefined,
			userConfig: {
				"lobbies": {
					"destroyOnEmptyAfter": 60000,
					"unreadyExpireAfter": 300000,
					"maxPlayers": 16,
					"maxPlayersDirect": 16,
					"enableCreate": false,
					"enableDestroy": false,
					"enableFind": true,
					"enableFindOrCreate": true,
					"enableJoin": true,
					"enableList": true,
					"regions": ["local"],
					"backend": {
						"localDevelopment": {
							"tags": { "test": "5" },
							"ports": { "game": { "protocol": "udp", "port": 7777 } },
						},
					},
				},
				"lobbyRules": [],
				"players": {
					"maxPerIp": 8,
					"maxUnconnected": 128,
					"unconnectedExpireAfter": 60000,
					"autoDestroyAfter": 4147200000,
				},
			},
		},
		"rivet": {
			"storageAlias": "rivet",
			scripts: {
				"call": {
					run: modules$$rivet$$call$$run,
					public: false,
					requestSchema: z.object({
						method: z.string(),
						path: z.string(),
						body: z.optional(
							z.any(),
						),
					}),
					responseSchema: z.object({ body: z.any() }),
				},
			},
			actors: {},
			routes: {},
			errors: {
				"rivet_error": {
					"name": "Rivet Error",
					"description": "An error from the Rivet API.",
				},
			},
			dependencies: new Set(["rivet"]),
			db: undefined,
			userConfig: {
				"apiEndpoint": "https://api.rivet.gg",
				"serviceTokenVariable": "RIVET_SERVICE_TOKEN",
			},
		},
	},

	db: {
		createPgPool: (url: URL) => {
			return new pg.Pool({
				connectionString: url.toString(),
			});
		},
	},
} as Config;
